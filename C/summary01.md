### 1. 자료구조와 알고리즘
1. 자료구조      
    - 자료를 효율적으로 처리할 수 있도록 조직적·채계적으로 정리한 것
    - 여러 데이터들을 묶음으로 저장하고, 사용방법을 정리함
    - 종류▶ 1)선형구조(리스트 / 스택 / 큐) / 2) 비선형구조(트리 / 그래프)
2. 알고리즘   
    - 주어진 문제를 처리하는 단계를 기술하고 특정한 일을 수행하도록 하는 절차   
    - 알고리즘의 조건▶ 입력 / 출력 / 명확 / 유한 / 유효   
        - 1)입력: 0개 이상 / 2)출력: 1개 이상 / 3)명확성: 모호하면 안됨 / 4) 유한성: 반드시 종료 / 5)유효성: 실행 가능한 연산   
    - 알고리즘의 구성▶ 1) sequence / 2) Selection / 3) Repetition
    - 기술방법▶ 1) 자연어 / 2) 순서도 / <b>3) 의사코드</b> / 4) 프로그래밍언어   
3. 프로그램: 자료구조 + 알고리즘   

### 2. 추상자료형(ADT, Abstract Data Type)
1. 자료형의 종류   
    - 기본자료형(char, int, float, void)
    - 파생자료형(function, array, struct, pointer)   
2. 데이터 타입이 가지는 것: 1)데이터 2)연산   
    - 예) INT의 집합: {-INT_MIN, ..., -1, -2, 0, 1, 2, ...  INT_MAX}   
               연산: +, - , *, /, %, ==, >, <, ...   
    - ADT도 데이터와 연산으로 이루어짐   
3. ADT의 정의   
    - 데이터타입의 추상적인 정의이다. (추상적이란? 사용자에게 중요한 정보를 강조하고 중요하지 않은 정보는 제거하는 것)   
    - 데이터의 연산이 <b>무엇</b>인지 정의하는 것으로 어떻게는 신경쓰지 않는다.   
    - 추상화 -> 정보은닉법 -> 추상자료형   

### 3. 알고리즘의 성능분석
1. 성능을 분석하는 방법   
    - 수행시간을 측정하는 방법: 실제 수행시간을 동일한 하드웨어에서 동시에 구현함   
    - 알고리즘의 복잡도 분석: 직접 구현하지 않고 수행시간을 분석함 -> HOW? 알고리즘의 연산 횟수를 측정비교함   
2. 빅오표기법(알고리즘 복잡도 분석)   
    - 정의: 연산횟수 대략적으로 표기한 것이며, 불필요한 정보는 제거해 알고리즘을 쉽게할 목적으로 사용함   
            keypoint! 연산의 개수보다 증가 추세가 중요함   
                      <b>자료의 개수가 많은 경우 차수가 가장 큰 항이 큰 영향을 미침</b>   
    - 특징: 함수의 상한을 표시(최악의 경우를 나타냄)   
    - 빠른 실행 순서: O(1) > O(log n) > O(n) > O(n log n) > O(n^2) > O(n^3) > O(2^n) > O(n!)   
                     보통 지수형(O(2^n))부터는 절대 쓰지 않는 것이 좋음      
3. 기타 알고리즘 복잡도 분석   
    - 빅오메가: 함수의 하한을 표시(최상의 경우 나타냄)   
    - 빅세타: 함수의 상한과 하한을 동시에 나타냄(최상, 최악)   
   
#

### 2. 순환
1. 순환
    - 알고리즘 또는 함수가 지기 자신을 호추ㄹ해 문제를 해결함
    - 적합한경우: 정의 자체가 순환적일 때
    - 순환 -> 반복: 때때로 OK, 모든 반복->순환: NO
    - 순환은 스택을 사용함

2. 정리   

|비교|순환|반복|
|------|---|---|
|장점|순환문제에서 자유로움|수행속도가 빠름|
|단점|함수호출의 overhead|순환적 문제에 대한 프로그램 작성 어려움|

|비교|순환|반복|
|------|---|---|
|팩토리얼|O(n)|O(n)|
|거듭제곱|O(n)|O(log n)|
|피보나치|O(2^n)|O(n)|  

*거듭제곱: 개념-반복 / 효율-순환   
*피보나치: 개념-순환 / 효율-반복   

#
### 3. 배열과 구조체, 포인터
1. 배열: 타입이 같은 데이터를 하나로 묶음   
    - ADT
```markdown
객체: <인덱스, 요소>   
연산:
    create(size): size개의 요소 생성할 수 있는 배열 생성
    get(A, i) = 배열 A의 i요소 반환
    set(A, i, v) = 배열의 A의 i번째 위치에 값V 저장
```
2. 구조체: 타입이 다른 데이터를 하나로 묶음   
3. 포인터: 다른 변수의 주소를 가진 변수   
    - 배열의 이름: 첫번째 인덱스의 주소를 가짐   
    - 포인터의 초기화   
      - 주소 연산자를 사용해 변수 주소를 지정   
      - 동적 메모리를 할당하면 그 시작 주소를 포인터 값으로 지정함   
      - 문자형 포인터에 문자열 시작 주소 지정   
4. 정리

|다항식|모든 항 저장|0이 아닌 항만 저장|
|------|---|---|
|장점|구현 간단|메모리 공간 절약|
|단점|메모리 공간 낭비|구현 복잡|


|희소행렬|모든 요소 저장|0이아닌 요소만 저장|
|------|---|---|
|장점|구현 간단|메모리 공간 절약|
|단점|메모리 공간 낭비|구현 복잡|

#

### 4. 스택
1. Last In First Out (LIFO)   
2. 구현방법: 1)배열(전역변수or구조체) / 2)리스트   
3. 스택의 ADT   
```markdown
객체: 0개 이상 원소를 가진 유한의 선형리스트
연산:
create(size) = 최대크기가 size인 배열 생성, top == -1
is_full(s) = 스택이 포화인지 검사
is_empty(s) = 스택이 공백인지 검사
push(s, item) = is_full(s)가 아니면 top 올리고 데이터 삽입
pop(s) - is_empty(s)가 아니면 원소 제거(=>how? 데이터를 다른 변수에 복사하고 top 내림)
peek(s) = is_empty(s)가 아니면 스택의 맨 위의 원소 반환
```
4. 스택의 응용   
    - 괄호검사   
        - 1)짝 2)개수 3)순서   
        - 방법: 스택에 여는 괄호 나오면 push -> 닫는 괄호 나오면 pop   
    - 수식계산   
        - 수식계산의 종류: 1)pre 2)infix 3)post   
        - 중위->후위 계산: 스택에 연산자만 나오면 push -> 피연산자 나오면 pop하고 출력
        - 후위표기법 계산: 스택에 피연산자 나오면 push -> 연산자 나오면 pop하고 출력
        - 후위표기식의 장점: 1) 괄호가 필요 없다. 2)우선순위를0 내제한다.

#
### 5. 큐
1. First In First out (FIFO)   
2. 추상데이터타입(ADT)   
        
```markdown
        객체: 0개 이상의 요소들로 구성된 선형리스트
        연산:
        <create(MAX_SIZE) = 최대크기 MAX_SIZE만큼의 공백큐 생성
        init(q)           = 큐를 초기화
        is_empty(q)       = if(size == 0) return TRUE;
                            else return FALSE;
        is_full(q)        = if(size == MAX_SIZE) return TRUE;
                            else return FALSE;
        enqueue(q, e)     = if(is_full(q)) queue full error;
                            else q의 끝에 e 추가**
        dequeue(q)        = if(is_empty(q)) queue empty error;
                            else q의 맨 앞에 있는 e를 제거하고 반환**
        peek(q)           = if(is_empty(q)) queue empty error;
                            else q의 맨 앞에 있는 e를 읽어서 반환**
```

3. 큐의 종류: 1)선형큐 / 2)원형큐 / 3)덱   
4. 응용: 대기열, printer-computer buffering   

5. 선형큐   
    - 구현방법: 1)배열 / 2)연결리스트   
    - 주의사항: index 올리고 data 추가: `q->data[++(q->rear)] = item;`   
               index 올리고 data 삭제: `itme = q->data[==(q->front)];`   

6. 원형큐
    - 구현방법: 1)배열 / 2)연결리스트
    - 주의사항:
```markdown
    공백상태: front == rear
    포화상태: front == (rear + 1) % MAX_SIZE
    *공백과 포화를 구분하기 위해 하나의 공간은 반드시 비워둠
```

# 6. 덱
1. 덱: 큐의 전단(front)과 후단(rear)에서 모두 삽입과 삭제가 가능한 큐(양방향 삽입삭제 가능)   
    - 추상데이터타입(ADT)   
```markdown
    객체: n개의 element형으로 구성된 요소들의 순서 있는 모임
    연산:
    crate()          = 덱 생성
    init(dq)         = 덱 초기화
    is_empty(dq)     = 덱이 공백인지 점검
    is_full(dq)      = 덱이 포화인지 점검
    add_front(dq, e) = 덱의 앞에 요소 추가
    add_rear(dq, e)  = 덱의 뒤에 요소 추가
    delete_front(dq) = 덱의 앞의 요소 반환한 후 삭제
    delete_rear(dq)  = 덱의 뒤의 요소 반환한 후 삭제
    get_front(q)     = 덱의 앞에서 삭제X, 앞에 있는 요소 반환 (peek)
    get_rear(q)      = 덱의 뒤에서 삭제X, 뒤에 있는 요소 반환 (peek) 
```
2. 덱의 연산   
    1. 덱의 전단(front)와 관련된 연산만 사용: 스택   
        - front에서 data가 add되다가 delete되면! 나중에 들어온 놈이 먼저 나가는 것   
    2. 삽입은 후단(rear), 삭제는 전단(front)에서 사용 : 큐   
        - rear에서 data add되다가 front에서 delete되면! 먼저 들어온 놈이 먼저 나가는 것   
3. 덱의 정의   
```markdown
    원형큐와 동일한 연산             : is_empty(), is_full(), init_queue()
    원형큐와 동일한데 이름만 바뀐 연산: add_rear(), delete_front(), get_front() 
                                      add_rear()= enqueue()
                                      delete_front() = dequeue()
                                      get_front() = peek
    새롭게 추가된 연산               : delete_rear(), delete_front(),
                                      add_front(), get_rear()
```
4. 주의사항   
    1. 반시계방향으로 회전 (queue는 시계방향)   
    2. deque[0]에서는 deque[MAX_SIZE-1]로 이동 해야함.   
```c
        dq->front = (front - 1 + MAX_SIZE) % MAX_SIZE
        dq->rear  = (rear - 1 + MAX_SIZE) % MAX_SIZE
```
        - 그래서 위와 같이 +MAX_SIZE로 보정을 해주는 것이다.
        - 보정을 안 할 경우 daque[0] 다음은 daque[-1]이 될 것.. 이러한 배열은 없으니까!(오버플로우방지)
5. 정리

|비교|선형큐|원형큐|
|------|---|---|
|장점|구현간단|선형큐의 문제 해결 가능|
|단점|삽입시 계속이동| |


### 7. 리스트
1. 일상 생활에서의 리스트 : 버킷 리스트, TODO리스트 등   
2. 추상 데이터 타입(ADT)   
```markdown
    객체: N개의 ELEMENT형으로 구성된 **순서 있는 모임**
    연산:
    1. insert(list, pos, item)  = pos위치에 요소 추가
    2. insert_last(list, item)  = 맨 끝에 요소 추가
    3. insert_first(list, item) = 맨 처음에 요소 추가
    4. delete(list, pos)        = pos위치에 요소 제거
    5. clear(list)              = 리스트의 모든 요소 제거
    6. get_entry(list, pos)     = pos위치의 요소 반환
    7. get_length(list)         = 리스트의 길이를 구함
    8. is_empty(list)           = 리스트 공백 검사
    9. is_full(list)            = 리스트 포화 검사
    10. print_list(list)        = 리스트의 모든 요소 표시
```
3. 배열 vs 리스트   

|비교|배열|연결리스트|
|------|---|---|
|구현|간단|복잡|
|탐색|쉬움|임의항목 추출시 어려움|
|크기제한|있음|없음|
|삽입삭제|불편|용이|
|삽입삭제시 자료이동|필요|불필요|
|리스트 크기|고정|동적|
|연속적 기억장소 할당|불필요|필요|

|연산|배열|연결리스트|
|------|---|---|
|읽기|O(1)|O(N)|
|검색|O(N)|O(N)
|삽입|O(N) (끝에서부터 하면 O(1))|O(N) (앞에서부터 하면 O(1))|
|삭제|O(N) (끝에서부터 하면 O(1))|O(N) (앞에서부터 하면 O(1))|


|링크|선형|원형|이중|
|------|---|---|---|
|개수|1개|1개|2개|
|마지막 링크|NULL|첫번째 노드|NULL|

*참고로 이중연결리스트는 링크가 전후를 가리킴

#
